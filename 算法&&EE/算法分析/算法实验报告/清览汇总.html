2 n=O(100n 2)
<br>答案
<br>错误
<br>
<br>10=θ(log10)
<br>答案
<br>正确
<br>
<br>2 n=O(3 n)
<br>答案
<br>正确
<br>
<br>logn 2=θ(logn+5)
<br>答案
<br>正确
<br>
<br>针对顺序查找算法，影响它时间复杂度的因素只有算法的输入序列()
<br>答案
<br>错误
<br>
<br>n!的时间复杂度为O(n)
<br>答案
<br>正确
<br>
<br>递归是指自己间接或直接调用自身
<br>答案
<br>正确
<br>
<br>算法的基本特征有（）
<br>答案
<br>输入
<br>
<br>渐进复杂性的含义是（）情况下的复杂性。
<br>答案
<br>问题规模趋向于无穷
<br>
<br>n个连续自然数a1...an连加和问题算法（利用等差数列求和公式）的输入可以是什么（）。
<br>答案
<br>a1，n
<br>
<br>平均时间复杂度是指（）
<br>答案
<br>各种情况时间复杂度按概率的加权平均
<br>
<br>算法的常见描述方式不包括（）
<br>答案
<br>甘特图
<br>
<br>算法的基本特性不包括（）
<br>答案
<br>先进性
<br>
<br>阶乘问题求n!算法的时间复杂度为（）。
<br>答案
<br>n
<br>
<br>二分搜索（二分查找）算法的时间复杂度是（）。
<br>答案
<br>logn
<br>
<br>汉诺塔问题的时间复杂度是（）。
<br>答案
<br>2^n
<br>
<br>下述描述算法的方式采用的是算法的哪种描述方式（）？

算法：gcd(m,n)

输入：非负整数m,n，其中m,n不全为0

输出：m与n的最大公约数

1.while m>0 do

2. r←n mod m

3. n ←m

4. m ←r

5.return n
<br>答案
<br>伪码
<br>
<br>背包问题的算法设计策略是（）
<br>答案
<br>单位重量价值大的优先装
<br>
<br>调度问题的算法设计策略是（）
<br>答案
<br>加工时间短的优先安排
<br>
<br>n个元素的冒泡排序代码如下：

def bubble_sort(arr):

  for i in range(len(arr) - 1):

  for j in range(len(arr) - i - 1):

  if arr[j] > arr[j + 1]:

  arr[j], arr[j + 1] = arr[j + 1], arr[j]

return arr


请分析算法的时间复杂度，用O表示（）
<br>答案
<br>
<br>
<br>百元买白鸡问题：鸡翁一，值钱五；鸡母一，值钱三；鸡雏三，值钱一；百钱买百鸡，则翁、母、雏各几何？设计一算法，则该算法的输入是（）
<br>答案
<br>无需任何输入
<br>
<br>下面算法最好情况下的时间复杂度___，最坏情况下的时间复杂度为___

def bubble_sort(nums):

        for i in range(len(nums) - 1):

            swap_flag = False  #改进后的冒泡，设置一个交换标志位

            for j in range(len(nums) - i - 1):

                if nums[j]>nums[j+1]:

                    nums[j],nums[j+1]=nums[j+1],nums[j]

                    swap_flag = True

            if not swap_flag:

                return nums  #若没有元素交换，则表示已经有序

        return nums
<br>答案
<br>O(n)、 <img  src="https://cdn1.qingline.net/d61861a5b2faa1ecb1522d77d786eb71.png"  />
<br>
<br>以下递归程序fun(5,0)输出的第一个元素是___，求解过程中最大层次为___

def fun(i,d):

  if(i>1 and i%2!=0):

fun(i-i//2,d+1)       

  if(i>1):

 fun(i//2,d+1)
<br>答案
<br>1、4
<br>
<br>斐波那契数列的第1项为1，第2项为2，以后每一项等于前面两项之和，则第6项为___
<br>答案
<br>13
<br>
<br>冒泡排序时间复杂度是___，堆排序时间复杂度是___。
<br>答案
<br><img  src="https://cdn1.qingline.net/8d1b0cce193d148418e59fa76b0dfd6c.png"  />、nlogn
<br>
<br>递归算法必须具备的两个条件是___和___
<br>答案
<br>边界条件或停止条件、递推方程或递归方程
<br>
<br>用O表示21+1/n的阶(O(1))
<br>答案
<br>O(1)
<br>
<br>用O表示10log3 n的阶()
<br>答案
<br>O(n)
<br>
<br>用O表示logn 3的阶()
<br>答案
<br>O(logn)
<br>
<br>用O表示的阶___
<br>答案
<br><img  src="https://cdn1.qingline.net/46581b7980051edceb52b968f53e2e5d.png"  />
<br>
<br>用O表示3n2+10n的阶___
<br>答案
<br><img  src="https://cdn1.qingline.net/fe158b0aad34f26a17d39bf06ec36749.png"  />
<br>
<br>请分析选择排序算法的时间复杂度，用O表示为:___

def selection_sort(arr):

    # 第一层for表示循环选择的遍数

    for i in range(len(arr) - 1):

          # 将起始元素设为最小元素

        min_index = i

          # 第二层for表示最小元素和后面的元素逐个比较

        for j in range(i + 1, len(arr)):

              if arr[j] < arr[min_index]:

                 # 如果当前元素比最小元素小，则把当前元素角标记为最小元素角标

                min_index = j

         # 查找一遍后将最小元素与起始元素互换

        arr[min_index] , arr[i] = arr[i] , arr[min_index]

    return arr
<br>答案
<br><img  src="https://cdn1.qingline.net/b9a1101afb3f1b7f1d08ba5e740c0590.png"  />
<br>
<br>请分析下面算法的时间复杂度：

def bubble_sort(nums):

        for i in range(len(nums) - 1):

            swap_flag = False  #改进后的冒泡，设置一个交换标志位

            for j in range(len(nums) - i - 1):

                if nums[j]>nums[j+1]:

                    nums[j],nums[j+1]=nums[j+1],nums[j]

                    swap_flag = True

            if not swap_flag:

                return nums  #若没有元素交换，则表示已经有序

        return nums
<br>答案
<br>最好情况下，比较n-1次，时间复杂度为O(n)

最坏情况下，比较n(n-1)/2次,时间复杂度为O(n^2)
<br>
<br>求递推方程得到的解是___
<br>答案
<br>O(nlogn)
<br>
<br>求递推方程得到的解是___
<br>答案
<br>O(logn)
<br>
<br>求递推方程的解是___
<br>答案
<br><img  src="https://cdn1.qingline.net/38775d2de17d5c2e9a3628e30523adf1.png"  />
<br>
<br>求递推方程得到的解是（）
<br>答案
<br>O(logn)
<br>
<br>求递推方程的解是（）
<br>答案
<br>O(n^2)
<br>
<br>物品可以切割的背包问题的最佳贪心策略不一定能保证装入背包的物品总价值最大。
<br>答案
<br>错误
<br>
<br>对下图分别用Kruskal算法和Prim算法求最小生成树。


<br>答案
<br>
<br>
<br>磁带最优存储问题：设有n 个程序{1,2,…, n }要存放在长度为L的磁带上。程序i存放在磁带上的长度是Li， 1≤i≤n。这n 个程序的读取概率分别是p1,p2,...,pn,且p1+p2+...+pn = 1。如果将这n 个程序按 1,2,....,n 的次序存放，则读取程序i所需的时间tr=c*(P1×L1+P2×L2+...+Pr×Lr)。这n 个程序的平均读取时间为 t1+t2+...+tn。实际上第k个程序的读取概率为ak/(a1+a2+...+an)。对所有输入均假定c=1。磁带最优存储问题要求确定这n个程序在磁带上的一个存储次序，使平均读取时间达到最小。试设计一个解此问题的算法,并分析算法的正确性和计算复杂性。
<br>答案
<br>def MinTime(n,l,p):

    t = []

    a = 0

    for i in range(n):

        a=a+p[i] #计算概率和

    for i in range(n):

        t.append(l[i]*p[i]/a)#存放i个程序的长度与读取概率的积

    t.sort()#由小到大到排序

    sum_time=0

    for i in range(n):

        sum_time=sum_time+(n-i) * t[i] #计算n个程序的平均读取时间 sum_time = n*t[0]+(n-1)*t[1]+...+t[n-1]

    return round(sum_time,4)#四舍五入，保留4位小数

if __name__=="__main__":

    n  = 5

    l = [71,46,9,73,35]

    p = [872,452,265,120,85]

    print(MinTime(n,l,p))

输出结果为：

85.6193
<br>
<br>设字符m1，m2，…m10的查阅频率依次为：0.05，0.01，0.01，0.10，0.03，0.17，0.0 2，0.24，0.31，0.06。试构造对应的哈夫曼(Haffman)编码，并画出相应的编码树，同时写出ml,m2,…m10的编码。
<br>答案
<br>每个字符的编码为从根节点到该字符所在叶子结点的路径上的0,1组成的串。
<br>
<br>在10000个元素中找到前100个最大的元素，如果使用以下某个数据结构作为辅助，比较合适的是()
<br>答案
<br>堆
<br>
<br>给定下面的有向、连通带权图





用dijkstra算法，找从源点1到其他各个顶点的最短路径。算法运行若干步以后，得到各数据结构的数据如下（数组下标从1开始，表示顶点编号）：

下标     11   22  3    4    5     6     7    88

S        1    1   0    1    0     1    1     0

dist     0    2   8    1    6     3    3    11

pre      0    1   2    1    7     1    4    7

根据当前状态，可判断从初始状态到当前状态已经做了（）次贪心选择。
<br>答案
<br>4
<br>
<br>



用Prim算法求解上图的最小生成树，初始时，集合S={a}，集合V-S={b,c,d,e,f,g}，第六步贪心选择的边是（）。
<br>答案
<br>（c,d）
<br>
<br>

用Prim算法求解上图的最小生成树，初始时，集合S={a}，集合V-S={b,c,d,e,f,g}，第三步贪心选择的边是（）。
<br>答案
<br>（c,f）
<br>
<br>

用Prim算法求解上图的最小生成树，初始时，集合S={a}，集合V-S={b,c,d,e,f,g}，第一步贪心选择的边是（）。
<br>答案
<br>（a,b）
<br>
<br>

用Kurskal算法求解上图的最小生成树，第一步贪心选择的边是（）。
<br>答案
<br>（c,f）
<br>
<br>给定一个有向连通带权图G=(V,E),n个顶点,e条边,Dijsktra算法的时间复杂度为()
<br>答案
<br>O(n 2)
<br>
<br>背包问题: n个物品和1个背包。对物品i,其价值为vi,重量为wi,背包的容量为W。如何选取物品装入背包,使背包中所装入的物品的总价值最大?物品可以分割。该问题的贪心策略是()。
<br>答案
<br>单位重量的价值大的优先装入背包
<br>
<br>调度问题:有n个客户带来n项任务,每项加工时间已知,设为ti,i=1,2,…,n。从0时刻开始,陆续安排到一台机器上加工。每个任务的完成时间是从0时刻到该任务加工完成的时间。为了使尽可能多的客户满意,我们希望找到是的总等待时间最少的调度方案。该问题的贪心策略是()
<br>答案
<br>加工时间短的优先安排
<br>
<br>找零钱问题的贪心策略是()
<br>答案
<br>面值小于待找钱数且面值最大的优先找出
<br>
<br>物品不可拆开的最优装载问题的贪心策略是()
<br>答案
<br>重量小的集装箱优先装
<br>
<br>会场安排问题的最好的贪心策略是()
<br>答案
<br>在不冲突的情况下，结束时间早的优先安排
<br>
<br>调度问题的算法设计策略是（）
<br>答案
<br>加工时间短的优先安排
<br>
<br>以下问题中，哪些问题的分治算法消耗的时间与输入序列无关.（）
<br>答案
<br>合并排序
<br>
<br>有关2个n位大整数乘法问题说法正确的是（）。
<br>答案
<br>将两个n位大整数分解为4个规模大致相等的n/2位整数的整数乘法问题
<br>
<br>分治算法的步骤有（）。
<br>答案
<br>分解
<br>
<br>分治算法的思想是（）。
<br>答案
<br>将规模较大的问题划分为规模较小的相同子问题
<br>
<br>大整数A和B的乘法,将A分成位数大致相等的两部分A1和A2 ，将B分成位数大致相等的两部分B1和B2,以下描述正确的是()。
<br>答案
<br>子问题的解归并为原问题解的方法为:A×B=10nA1B1+10n/2(A1B2+A2B1)+A2B2
<br>
<br>关于快速排序分治算法时间复杂度描述正确的是()
<br>答案
<br>快速排序分治算法最好情况下的时间复杂度为O(nlogn).
<br>
<br>有关快速排序的分治算法描述正确的是()。
<br>答案
<br>快速排序A[left,right],选取基准元素的方法,将待排序元素分解为两个子问题。
<br>
<br>关于二分查找时间复杂度描述正确的是()
<br>答案
<br>二分查找算法最好情况下的时间复杂度为O(1).
<br>
<br>有关合并排序的分治算法描述正确的是()
<br>答案
<br>合并排序A[left,right]的元素,采用的分解方法是(left+right)/2。
<br>
<br>有关循环赛日程表分治算法描述正确的是()
<br>答案
<br>循环赛日程表给定2 k个运动员,采用2 k/2的方法将运动员分成两组。
<br>
<br>下述关于二分查找(折半查找)算法描述正确的是()
<br>答案
<br>二分查找根据比较的结果,好的情况是相等,算法结束。坏的情况是进入其中一个子问题继续查找。
<br>
<br>分治算法核心就是分而治之,其中的“治”描述正确的是()。
<br>答案
<br>分治法通过治理小问题来治理大问题。
<br>
<br>分治算法的基本思想描述正确的是()
<br>答案
<br>分治法将规模大的问题分解成规模较小的问题解决。
<br>
<br>根据下面斐波那契数列的递归算法，可知斐波那契数列的第n项的递归式为（）。

def Fibonacci(int num):

  if(num == 0 || num == 1): 

      return num 

  return  Fibonacci(num-1)+Fibonacci(num - 2)
<br>答案
<br>Fibonacci(n)=Fibonacci(n-1)+Fibonacci(n-2) 当n〉1时
<br>
<br>下面代码为求n！的递归算法，该代码反应的n!问题递归实现的停止条件（边界条件）为（）。def fun(n):

  if (n == 1):

    return 1

else :

  return fun(n - 1) * n

<br>答案
<br>n!=1  当n=1时
<br>
<br>以下哪个问题的时间复杂度与输入序列有关（）
<br>答案
<br>二分查找
<br>
<br>以下函数的功能是（）

def Q(R, low，high): 

 if(low<high):#仅当区间长度大于1时才须排序

     pivotpos=Partition(R,low,high) #划分后的基准元素所对应的位置 

     Q(R,low,pivotpos-1)#对左区间递归排序 

     Q(R,pivotpos+1,high)#对右区间递归排序 
<br>答案
<br>快速排序
<br>
<br>以下代码功能为合并排序，请根据注释按照数顺序选择合适的语句填入对应的括号。

def MergeSort(A， low， high):

  if (low < high):

    （）#分解

（）# 递归序列左半部分

（）# 递归序列右半部分

Merge(A, low, middle, high)# 子问题的解合并成原问题的解

<br>答案
<br>middle=(low+high)/2;

MergeSort(A,low,middle);

MergeSort(A,middle+1,high);
<br>
<br>棋盘覆盖问题的分解方法为（）。
<br>答案
<br>
<br>
<br>合并排序的分治算法时间复杂度的是()
<br>答案
<br>O(nlogn)
<br>
<br>解决给定的5个矩阵连乘问题：矩阵A1（3×2）、A2（2×5）、A3（5×10）、A4（10×2）和A5（2×3），设m[i][j]表示Ai...Aj的最优计算次序对应的乘法计算次数（最优值），P为存储矩阵行列的数组，其中P[i]是第i个矩阵的列、第i-1个矩阵的行。求解最优值递归关系是为：，根据该递归关系式，求解过程中得到下面最优决策的二维表：





由此，可得上述5个矩阵连乘的最优计算次序为（）
<br>答案
<br>（A1（（A2（A3A4））A5））
<br>
<br>关于动态规划和回溯法的区别，以下表述不正确的是
<br>答案
<br>在求解相同问题时，动态规划必然比回溯法浪费空间，但是更节约时间
<br>
<br>关于动态规划与分治法的区别，表述不正确的是
<br>答案
<br>分治法能写成递归形式，动态规划不能写成递归形式
<br>
<br>矩阵连乘问题中，A1矩阵大小是100*5,A2矩阵大小为5*30，A3矩阵大小为30*10，则乘法次序 (A1*A2)*A3需要的乘法次数是
<br>答案
<br>45000
<br>
<br>规模为5矩阵连乘问题,计算次序有()种。
<br>答案
<br>14
<br>
<br>根据下面斐波那契数列的递归算法，可知斐波那契数列的第n项的递归式为（）。

def Fibonacci(int num):

  if(num == 0 || num == 1): 

      return num 

  return  Fibonacci(num-1)+Fibonacci(num - 2)
<br>答案
<br>Fibonacci(n)=Fibonacci(n-1)+Fibonacci(n-2) 当n〉1时
<br>
<br>下面代码为求n！的递归算法，该代码反应的n!问题递归实现的停止条件（边界条件）为（）。def fun(n):

  if (n == 1):

    return 1

else :

  return fun(n - 1) * n

<br>答案
<br>n!=1  当n=1时
<br>
<br>合并排序的空间复杂度为()
<br>答案
<br>θ(n)
<br>
<br>以下哪个问题的时间复杂度与输入序列有关（）
<br>答案
<br>二分查找
<br>
<br>以下函数的功能是（）

def Q(R, low，high): 

 if(low<high):#仅当区间长度大于1时才须排序

     pivotpos=Partition(R,low,high) #划分后的基准元素所对应的位置 

     Q(R,low,pivotpos-1)#对左区间递归排序 

     Q(R,pivotpos+1,high)#对右区间递归排序 
<br>答案
<br>快速排序
<br>
<br>以下代码功能为合并排序，请根据注释按照数顺序选择合适的语句填入对应的括号。

def MergeSort(A， low， high):

  if (low < high):

    （）#分解

（）# 递归序列左半部分

（）# 递归序列右半部分

Merge(A, low, middle, high)# 子问题的解合并成原问题的解

<br>答案
<br>middle=(low+high)/2;

MergeSort(A,low,middle);

MergeSort(A,middle+1,high);
<br>
<br>合并排序的分治算法时间复杂度的是()
<br>答案
<br>O(nlogn)
<br>
<br>矩阵连乘问题中有多个矩阵相乘，问题是安排矩阵相乘的先后顺序，使总乘法次数最少，例如 有[A][B]C三个矩阵，则可行的顺序有ABC\ACB\CAB\CBA\BAC\BCA六个。
<br>答案
<br>错误
<br>
<br>以动态规划求解0-1背包问题，背包容量可以是任意实数。
<br>答案
<br>错误
<br>
<br>有关矩阵连乘问题说法正确的是()
<br>答案
<br>矩阵A i...A j连乘,其中A k的行列为(p k×q k),k=i,i+1,...,j,其结果矩阵的行列为(p i×q j)。
<br>
<br>动态规划的基本要素是()
<br>答案
<br>重叠子问题
<br>
<br>有关动态规划描述正确的是()
<br>答案
<br>动态规划将多阶段决策问题转化为单阶段决策问题。
<br>
<br>设c[i][j]表示序列Xi和Yj的最长公共子序列的长度。则它的递推关系式为：





则，根据给定的X=={A, B, C, B, D, A, B}和Y={B, D, C, A, B, A}从上到下填写缺失值。

208089516230602074545140081017633951191260
<br>答案
<br>3 4 4
<br>
<br>给定序列X={A, B, C, B, D, A, B}和Y={B, D, C, A, B, A}，它们的最长公共子序列是（）。
<br>答案
<br>BCBA
<br>
<br>按照顺序排列动态规划的求解步骤,正确的是()

（1)递归定义最优值。

（2)以自底向上的方式计算出最优值,并记录相关信息。

（3）分析最优解子结构性质。

（4)构造出最优解。
<br>答案
<br>(3),(1),(2),(4)
<br>
<br>以下算法框架中，哪个是排列树模型的算法设计模式（）
<br>答案
<br>def Backtrack (t):

    if (t>n):

         output(x)

    else:

         for i in range(t,n+1):

          x[t], x[i]←x[i], x[t]

          if (constraint(t) and bound(t)):

                 Backtrack(t+1)

          x[t], x[i]←x[i], x[t]
<br>
<br>最优化问题优化目标是使求目标函数最大化，基于回溯法求解该问题。如果对于解空间的任何分支X，均可求出目标函数值的两个上界lb1(X)和lb2(X)，且总有lb1（X）>=lb2(X),则如果想用于剪枝，从减少搜索节点的角度，哪个界限更优？
<br>答案
<br>lb2
<br>
<br>0-1背包问题的解空间结构属于（）
<br>答案
<br>子集树
<br>
<br>以下关于回溯法的说法，错误的是
<br>答案
<br>回溯法能够保证生成时间复杂度较低的算法
<br>
<br>现有一个用于求解最优化问题的回溯算法，在搜索过程中涉及的函数的描述，错误的是
<br>答案
<br>在目标函数最小化问题中，限界函数应当使用上界
<br>
<br>关于旅行商问题的说法，错误的是
<br>答案
<br>旅行商问题的解空间与最短路径问题相同
<br>
<br>以下有关旅行商问题的递归代码，根据注释判断空缺部分填写正确的是（）。

def Traveling(t):

(       )#到达叶子结点

    #g存储图的邻接矩阵，x是存储解向量，初始化为x[1:n]={1,2,...,n},cl是当前已走的路经长度，bestl是当前已找到的最短路径长度。

      if(g[x[n] ][1] !=∞ and (cl+g[x[n]][1]< bestl ) ):

         for j in range(1,n+1):  

               bestx[j]=x[j]

         bestl=cl+g[x[n]][1]

else:#没有到达叶子结点

       (      ) #控制当前节点的分支数目，即对xt的所有可能的取值。

    if( g[x[t-1]][x[j]] !=∞ and(cl+g[x[t-1]][x[j]]< bestl) ):

#保存第t个要去的城市编号到x[t]中，进入到第t+1层

           x[t],x[j]=x[j],x[t] #交换两个元素的值

             cl+=g[x[t-1]][x[j]]

              Traveling(t+1)#从第t+1层的扩展结点继续搜索

              #第t+1层搜索完毕，回溯到第t层

            cl-=g[x[t-1]][x[j]]

             x[t],x[j]=x[j],x[t]
<br>答案
<br>空1：if(t>n)

空2：for(j=t;j<=n;j++)
<br>
<br>有关回溯法说法正确的是（）
<br>答案
<br>回溯法是一种深度优先搜索的搜索算法
<br>
<br>有关n皇后问题说法正确的是（）
<br>答案
<br>该问题的解的形式为(x1, x2, … , xn)，xi表示第i个皇后位于第i行、第xi列(i=1,2,3,...n)
<br>
<br>下述有关搜索过程描述错误的是（）
<br>答案
<br>搜索过程中，所有孩子节点均已生成的节点称为扩展节点
<br>
<br>以下描述中，影响回溯法的搜索效率的是（）
<br>答案
<br>问题的解空间，即搜索范围
<br>
<br>以下有关子集树的描述中说法正确的是（）
<br>答案
<br>当所给的问题是从n个元素组成的集合S中找出满足某种性质的一个子集时，相应的解空间树称为子集树。
<br>
<br>有关子集树描述中，说法错误的是（）
<br>答案
<br>子集树的根结点为问题的初始状态
<br>
<br>有关0-1背包问题说法正确的是（）
<br>答案
<br>该问题的解的形式为(x1, x2, … , xn)，xi(i=1,2,3,...n)的取值为0或1
<br>
<br>有关下图说法正确的是（）


<br>答案
<br>该树表示的问题的规模为3
<br>
<br>有关批处理作业调度问题说法正确的是（）
<br>答案
<br>该问题的解形式为(x1,x2,…,xn)，xi取值范围为：令S={1,2,…,n}，则xi∈S-{x1,x2,…,xi-1}，i=1,2,...,n
<br>
<br>有关旅行售货员问题说法正确的是（）
<br>答案
<br>该问题的解空间的组织结构是排列树。
<br>
<br>有关回溯法说法正确的是（）
<br>答案
<br>回溯法是一种深度优先搜索的搜索算法
<br>
<br>有关n皇后问题说法正确的是（）
<br>答案
<br>该问题的解的形式为(x1, x2, … , xn)，xi表示第i个皇后位于第i行、第xi列(i=1,2,3,...n)
<br>
<br>以下描述中，影响回溯法的搜索效率的是（）
<br>答案
<br>问题的解空间，即搜索范围
<br>
<br>有关随机化算法错误的是（）
<br>答案
<br>数值随机化算法常用于数值问题的求解，所得到的解都是精确解。
<br>
<br>有关估算π值的随机化算法说法错误的是（）
<br>答案
<br>估算π值的随机化算法估算的近似值的精度与算法消耗的时间无关
<br>
<br>有关主元素问题的蒙特卡罗算法说法错误的是（）
<br>答案
<br>主元素问题的蒙特卡罗算法得到正确解的概率随算法消耗的时间的增加而降低 。
<br>
<br>有关素数测试问题算法说法正确的是（）
<br>答案
<br>根据二次探测定理设计的素数测试蒙特卡罗算法得到的解为正确解的概率大于0.5
<br>
<br>有关n皇后问题的拉斯维加斯算法说法正确的是（）
<br>答案
<br>n皇后问题的拉斯维加斯算法可以采用对不冲突的多个列位置进行随机。
<br>
<br>有关随机快速排序算法说法错误的是（）
<br>答案
<br>随机快速排序每次运行都能够得到解，但是得到的解不一定正确。
<br>
<br>有关整数n的因子分解问题说法正确的是（）
<br>答案
<br>Pollard算法，只要给足够的时间，肯定能找到整数n的因子。
<br>
<br>以下有关随机数产生的线性同余法说法正确的是（）
<br>答案
<br>线性同余法产生的随机数是伪随机数。
<br>
<br>以下有关随机选择第k小算法正确的是（）
<br>答案
<br>随机选择第k小算法中的随机性和随机快速排序的随机性一样，都是随机选择基准元素。
<br>
<br>通过多次执行的方式提高随机算法得到正确解的概率的算法是（）
<br>答案
<br>蒙特卡罗算法
<br>
<br>以下算法中，通过多次执行能够提高算法得到解的概率的算法是（）
<br>答案
<br>拉斯维加斯算法
<br>
<br>以下算法中，哪个算法用于求问题的近似解，求得近似解的精确程度与算法消耗的时间相关（）
<br>答案
<br>数值随机化算法
<br>
<br>有关随机化算法正确的是（）
<br>答案
<br>随机化算法的特征是对所求解问题的同一实例用同一随机化算法求解两次可能得到完全不同的效果，这两次求解问题所需的时间甚至所得到的结果可能会有相当大的差别。
<br>
<br>有关估算π值的随机化算法说法错误的是（）
<br>答案
<br>估算π值的随机化算法随机实验次数越多，估算的π值精度越低
<br>
<br>有关随机快速排序算法说法正确的是（）
<br>答案
<br>随机快速排序与快速排序的区别是随机快速排序随机选择基准元素，而快速排序的确定性算法选择固定位置的元素作为基准元素。
<br>
<br>以下随机化算法能得能保证得到的解是正确解的算法是（）
<br>答案
<br>拉斯维加斯算法
<br>
<br>随机化算法的特征是对所求解问题的同一实例用同一随机化算法求解两次可能得到完全不同的效果，这两次求解问题所需的时间甚至所得到的结果一定会有相当大的差别。
<br>答案
<br>错误
<br>
<br>蒙特卡罗算法用于求问题的正确解。
<br>答案
<br>错误
<br>
<br>拉斯维加斯算法绝不返回错误的解，但有时得不到问题的解。可以通过多次执行提高算法得到解的概率。
<br>答案
<br>正确
<br>
<br>随机快速排序随机选择一个元素作为基准元素，根据划分的结果，递归解决两个子问题。
<br>答案
<br>正确
<br>
<br>